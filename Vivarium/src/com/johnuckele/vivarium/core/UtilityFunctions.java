package com.johnuckele.vivarium.core;

import java.util.Random;

public class UtilityFunctions
{
	// Random number state
	private static Random _random = new Random();
	private static long _randomLong = (long)(_random.nextDouble()*(Long.MAX_VALUE-1)+1);

	/**
	 * Sets the pseudorandom seed to generate predictable behavior. javaRandomDouble uses LCG
	 * and this class has a slightly faster Xorshift algorithm. Setting this seed will
	 * set the seeds for both the LCG and Xorshift seeds, which become independent after
	 * the initial set.
	 * 
	 * If this seed is not set, the LCG randoms will be initialized by the default
	 * java.util.Random() constructor, and the Xorshift seed will be generated by the
	 * first value taken from the Random instance.
	 * 
	 * @param seed the seed to set, must not be zero
	 */
	public static void setRandomSeed(int seed)
	{
		if(seed == 0)
		{
//			throw new Error("Random seeds cannot be zero");
		}
		_random = new Random(seed);
		_randomLong = seed;
	}

	/**
	 * Sets the seed to a psuedorandomly generated value. This is useful for test clearing a
	 * deliberately set seed in test cases.
	 */
	public static void setRandomSeed()
	{
		_random = new Random();
		_randomLong = (long)(_random.nextDouble()*(Long.MAX_VALUE-1)+1);
	}

	/**
	 * Get a pseudorandom double with the range (-1,1)
	 * @return A pseudorandom double
	 */
	public static double getRandomDouble() {
		return (double) UtilityFunctions.getRandomLong() / Long.MAX_VALUE;
	}
	/**
	 * Get a pseudorandom positive double with the range [0,1)
	 * @return A pseudorandom double
	 */
	public static double getRandomPositiveDouble() {
		return _random.nextDouble();
	}
	/**
	 * Get a pseudorandom int with range [0,range)
	 * @param range the number of possible return values
	 * @return A pseudorandom double [0,range)
	 */
	public static int getRandomInt(int range) {
		return (int) _random.nextDouble()*range;
	}
	/**
	 * Get a pseudorandom double from a Gaussian
	 * distribution with a mean of 0.0
	 * and a standard deviation of 1.0
	 * @return A pseudorandom Gaussian double
	 */
	public static double getRandomGaussian() {
		return _random.nextGaussian();
	}
	/**
	 * Get a psuedorandom long
	 * @return A pseudorandom long
	 */
	public static long getRandomLong() {
		_randomLong ^= (_randomLong << 21);
		_randomLong ^= (_randomLong >>> 35);
		_randomLong ^= (_randomLong << 4);
		return _randomLong;
	}

	/**
	 * computes the logistic sigmoid of a value,
	 * the logistic sigmoid is s(x) = 1 / ( 1 + e ^ -x )
	 * 
	 * @param x
	 * @return sigmoid(x)
	 */
	public static double sigmoid(double x)
	{
		return 1 / (1 + Math.exp(-x));
	}

	/**
	 * computes the midpoint between two values on a logarithmic
	 * scale, defined as log((exp(A)+exp(B))/2), but is usable
	 * even when A or B are too large to fit into Java primitives.
	 * 
	 * @param logA
	 *            the log of A
	 * @param logB
	 *            the log of B
	 * @return log((A+B)/2)
	 */
	public static double logarithmicAverage(double logA, double logB)
	{
		double difference = Math.abs(logA - logB);
		double expandedDifference = Math.exp(difference);
		return Math.log((expandedDifference + 1) / 2) + Math.min(logA, logB);
	}
}
