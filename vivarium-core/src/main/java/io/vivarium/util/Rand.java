/*
 * The MIT License (MIT)
 *
 * Copyright Â© 2015 John H. Uckele
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright
 * notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package io.vivarium.util;

import java.util.Random;

public class Rand
{
    // Random number state
    private static Random _random = new Random();
    private static long _randomLong = (long) (_random.nextDouble() * (Long.MAX_VALUE - 1) + 1);
    private static long _randomLong2 = (long) (_random.nextDouble() * (Long.MAX_VALUE - 1) + 1);

    /**
     * Sets the psuedorandom seed to generate predictable behavior. javaRandomDouble uses LCG and this class has a
     * slightly faster Xorshift algorithm. Setting this seed will set the seeds for both the LCG and Xorshift seeds,
     * which become independent after the initial set.
     *
     * If this seed is not set, the LCG randoms will be initialized by the default java.util.Random() constructor, and
     * the Xorshift seed will be generated by the first value taken from the Random instance.
     *
     * @param seed
     *            the seed to set, must not be zero
     */
    public static void setRandomSeed(int seed)
    {
        if (seed == 0)
        {
            // throw new Error("Random seeds cannot be zero");
        }
        _random = new Random(seed);
        _randomLong = seed;
        _randomLong2 = seed;
    }

    /**
     * Sets the seed to a psuedorandomly generated value. This is useful for test clearing a deliberately set seed in
     * test cases.
     */
    public static void setRandomSeed()
    {
        _random = new Random();
        _randomLong = (long) (_random.nextDouble() * (Long.MAX_VALUE - 1) + 1);
    }

    /**
     * Get a psuedorandom double with the range (-1,1)
     *
     * @return A psuedorandom double
     */
    public static double getRandomDouble()
    {
        return (double) Rand.getRandomLong() / Long.MAX_VALUE;
    }

    /**
     * Get a psuedorandom positive double with the range [0,1)
     *
     * @return A psuedorandom double
     */
    public static double getRandomPositiveDouble()
    {
        return _random.nextDouble();
    }

    /**
     * Get a psuedorandom int with range [0,range)
     *
     * @param range
     *            the number of possible return values
     * @return A psuedorandom double [0,range)
     */
    public static int getRandomInt(int range)
    {
        return _random.nextInt(range);
    }

    /**
     * Get a psuedorandom double from a Gaussian distribution with a mean of 0.0 and a standard deviation of 1.0
     *
     * @return A psuedorandom Gaussian double
     */
    public static double getRandomGaussian()
    {
        return _random.nextGaussian();
    }

    /**
     * Get a psuedorandom long generated with XorShift.
     *
     * @return A psuedorandom long
     */
    public static long getRandomLong()
    {
        _randomLong ^= (_randomLong << 21);
        _randomLong ^= (_randomLong >>> 35);
        _randomLong ^= (_randomLong << 4);
        return _randomLong;
    }

    /**
     * Get a psuedorandom long generated with XorShift. This long uses a different seed from the getRandomLong method,
     * in case a caller needs two independent random numbers.
     *
     * @return A psuedorandom long
     */
    public static long getRandomLong2()
    {
        _randomLong2 ^= (_randomLong2 << 21);
        _randomLong2 ^= (_randomLong2 >>> 35);
        _randomLong2 ^= (_randomLong2 << 4);
        return _randomLong2;
    }

}
